# Memoizing Expensive Components in React Native

Interview Preparation Answer

---

## ‚úÖ What is memoization?

**Memoization** means caching the result of a computation so that the function/component doesn't run again unless its inputs (props) change.
In React Native, this helps avoid unnecessary re-renders of components that take a lot of computation or heavy UI rendering.

---

## ‚úÖ Why is memoization needed?

Some components are expensive because they may:

- Render large lists
- Perform heavy calculations
- Fetch or process data
- Contain complex UI elements or animations

If these components re-render unnecessarily, the app may feel slow or laggy, especially on low-end devices.

---

## ‚≠ê How to memoize components in React Native

### 1Ô∏è‚É£ Using React.memo() for functional components

`React.memo` prevents a component from re-rendering unless its props change.

**Example:**

```javascript
const ExpensiveComponent = React.memo(({ data }) => {
  // heavy rendering logic
  return (
    <View>
      <Text>{data.value}</Text>
    </View>
  );
});
```

**How it works:**

- React compares previous props vs new props
- If they are the same ‚Üí component skips re-render
- If different ‚Üí component re-renders

---

### 2Ô∏è‚É£ Using useMemo for expensive calculations

Use `useMemo` when a value is expensive to compute.

```javascript
const result = useMemo(() => heavyCalculation(data), [data]);
```

This ensures the calculation only runs when `data` changes.

---

### 3Ô∏è‚É£ Using useCallback for memoizing functions

Useful when passing callbacks to memoized components.

```javascript
const onPress = useCallback(() => {
  console.log('Clicked!');
}, []);
```

Without `useCallback`, functions re-create on every render and cause unnecessary child re-renders.

---

## üî• When should you memoize?

Use memoization when:

- A component renders large lists (FlatList, SectionList)
- A component does expensive layout/animation
- A child gets re-rendered often due to changing parent state
- You pass functions or objects as props

---

## ‚ö†Ô∏è When NOT to memoize?

Avoid memoization if:

- Component is small and cheap
- Props change very frequently
- You optimize prematurely ‚Äî it adds complexity

---

## üß† Example Scenario (Interview-friendly)

**Question:**
"When would you use React.memo in React Native?"

**Answer:**

> "I use `React.memo` when a component is expensive to render, such as a list item in a FlatList. If the parent re-renders, I want to avoid re-rendering each list item unnecessarily. Memoizing keeps the UI smooth and improves performance."

---

## ‚≠ê Summary for Interview

- **Memoization = cache result to avoid unnecessary work**
- Use `React.memo` for components
- Use `useMemo` for computations
- Use `useCallback` for functions
- Helps improve performance, especially in large or complex UIs
