# Avoiding Unnecessary Re-renders in React Native

**Why it matters:**
Unnecessary re-renders reduce performance, cause UI lag, impact animations, and slow down lists in React Native.

---

## âœ… 1. Why React Components Re-render

React re-renders a component when:

- Its **state** changes
- Its **props** change
- Its **parent component re-renders** (and passes new props)

React Native components behave exactly the same way.

---

## ðŸ”§ Techniques to Avoid Unnecessary Re-renders

### 2. Use React.memo() for Pure Functional Components

`React.memo()` wraps a component and prevents re-rendering unless props actually change.

**ðŸ’¡ Example:**

```javascript
const UserCard = React.memo(({ name }) => {
  return <Text>{name}</Text>;
});
```

**When to use:**

- In UI-heavy components
- In lists (FlatList item components)
- When props rarely change

---

### 3. Use useCallback() for Stable Function References

Functions get recreated on every render â†’ this causes child components to re-render.

**ðŸ›  Fix:**

```javascript
const handlePress = useCallback(() => {
  console.log('Pressed!');
}, []);
```

This ensures the same function reference is passed to children.

---

### 4. Use useMemo() to Memoize Expensive Computations

If you calculate something heavy on each render, memoize it.

```javascript
const sortedList = useMemo(() => {
  return items.sort();
}, [items]);
```

---

### 5. Correctly Use keyExtractor in FlatList

An unstable key causes every item to re-render.

**Good keys:**

```javascript
keyExtractor={(item) => item.id}
```

**Bad:**

```javascript
keyExtractor={(item, index) => index}   // Causes re-renders when data changes
```

---

### 6. Avoid Inline Objects & Functions as Props

Inline objects/functions create new references each render.

**Bad:**

```javascript
<Item style={{ padding: 10 }} onPress={() => doSomething()} />
```

**Better:**

```javascript
const styles = { padding: 10 };
const handlePress = useCallback(doSomething, []);

<Item style={styles} onPress={handlePress} />;
```

---

### 7. Avoid Unnecessary State in Parent Components

Prop drilling and state kept too high in the tree cause frequent re-renders.

**Better strategy:**

- Keep state close to where it's used
- Use tools like Context, Redux, Zustand, or React Query

---

### 8. Use useRef for Values That Should Not Trigger Re-renders

For values that don't need UI updates:

```javascript
const countRef = useRef(0);
countRef.current += 1; // No re-render
```

---

### 9. Optimize Lists (Very Important for RN!)

React Native lists are heavy â†’ optimizing them is essential.

**Key optimizations:**

- Use `React.memo()` for item components
- Use `useCallback()` for `renderItem`
- Provide `getItemLayout`
- Use `windowSize`, `initialNumToRender`, etc.

```javascript
const renderItem = useCallback(({ item }) => <MemoizedItem data={item} />, []);
```

---

### 10. Use shouldComponentUpdate or PureComponent (Class Components)

If working with class components:

- `PureComponent` automatically prevents re-renders with shallow comparison
- `shouldComponentUpdate()` gives manual control

---

## ðŸ§  Interview Tip

**If asked: "How do you avoid re-renders in React Native?"**

A complete answer should include:

> "I avoid unnecessary re-renders using `React.memo` for memoizing components, `useCallback` and `useMemo` for memoizing function and value references, using stable keys in lists, avoiding inline objects/functions, using `useRef` for non-UI values, minimizing state in parents, and optimizing FlatList with memoized `renderItem`."

**This answer shows both conceptual knowledge and practical experience.**
