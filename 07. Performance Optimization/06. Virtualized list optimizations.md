# Virtualized List Optimizations in React Native

---

## âœ… What is a Virtualized List?

In React Native, a **virtualized list** renders only the items currently visible on screen (plus a small buffer) instead of rendering all items at once.

This drastically improves performance, memory usage, and scroll smoothness.

---

## âœ… Why Virtualization Is Important

**Without virtualization:**

- Huge memory usage
- Slow renders
- Dropped frames (janky scrolling)
- App crashes on low-end devices

**With virtualization:**

- Fast scrolling
- Lower memory usage
- Improved Time To Interactive (TTI)

---

## âœ… Built-in Virtualized List Components

These components use virtualization internally:

| Component         | Use Case            |
| ----------------- | ------------------- |
| `FlatList`        | Single-column lists |
| `SectionList`     | Grouped lists       |
| `VirtualizedList` | Advanced/custom use |

---

## âœ… Key Optimization Props (VERY IMPORTANT)

### ðŸ”¹ keyExtractor

```javascript
keyExtractor={(item) => item.id}
```

âœ… Use stable, unique IDs  
âŒ Never use index

**ðŸ’¡ Why?** Prevents unnecessary re-renders and layout shifts.

---

### ðŸ”¹ initialNumToRender

```javascript
initialNumToRender={10}
```

Controls how many items are rendered initially.

âœ… Set this low but enough to fill the screen  
âŒ Too large = slow startup

---

### ðŸ”¹ windowSize

```javascript
windowSize={5}
```

Number of visible screens to render (before + after).

- **Default:** 21
- Smaller value âžœ lower memory, risk of blank areas
- Larger value âžœ smoother scrolling, more memory

**âœ… Recommended interview answer:**

> Adjust `windowSize` based on scroll speed and memory tradeoff.

---

### ðŸ”¹ maxToRenderPerBatch

```javascript
maxToRenderPerBatch={10}
```

Controls how many items render per batch during scrolling.

âœ… Smaller batches reduce JS thread blocking  
âœ… Bigger batches feel smoother but cost performance

---

### ðŸ”¹ updateCellsBatchingPeriod

```javascript
updateCellsBatchingPeriod={50}
```

Time (ms) between batch renders.

âœ… Lower = faster render  
âœ… Higher = less JS work

---

## âœ… Avoid Re-rendering Items (CRITICAL)

### ðŸ”¹ Use React.memo

```javascript
const ListItem = React.memo(({ item }) => {
  return <Text>{item.title}</Text>;
});
```

âœ… Prevents re-rendering unchanged rows  
ðŸ“Œ VERY common interview question

---

### ðŸ”¹ Use useCallback

```javascript
const renderItem = useCallback(({ item }) => <ListItem item={item} />, []);
```

âœ… Prevents re-creating functions on each render

---

## âœ… Use getItemLayout (BIG performance win!)

```javascript
getItemLayout={(data, index) => ({
  length: 80,
  offset: 80 * index,
  index,
})}
```

**âœ… Enables:**

- Fast scrolling
- `scrollToIndex`
- No layout measuring

**ðŸ“Œ ONLY if item height is fixed**

---

## âœ… Extra Performance Flags

### ðŸ”¹ removeClippedSubviews

```javascript
removeClippedSubviews={true}
```

âœ… Removes off-screen items from native view hierarchy  
âœ… Improves memory  
âŒ May cause issues with shadows / animations

---

### ðŸ”¹ onEndReachedThreshold

```javascript
onEndReachedThreshold={0.5}
```

âœ… Helps with smooth pagination  
âœ… Prevents late data fetching

---

## âœ… Common Interview Mistakes âŒ

âŒ Using ScrollView for large lists  
âŒ Missing keyExtractor  
âŒ Inline renderItem functions  
âŒ No memoization  
âŒ Dynamic heights without optimization

---

## âœ… Interview One-Line Summary

> "React Native uses virtualized lists like FlatList to render only visible rows. Performance can be optimized using memoization, batching, window sizing, stable keys, and layout pre-calculation."

---

## âœ… Bonus: When NOT to Optimize

âœ… Lists under 20â€“30 items  
âœ… Static content  
âœ… Non-scroll-heavy screens
