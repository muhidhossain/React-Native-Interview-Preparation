# React Native Bridge Concept (Interview-Ready Explanation)

React Native allows you to build mobile apps using JavaScript while still using native components (UIButton, UIView, TextView, etc.) under the hood.
To make JavaScript code communicate with native modules, React Native uses something called the **Bridge**.

---

## ðŸ§  1. What is the Bridge?

The **Bridge** is an asynchronous, batched communication layer between:

### âœ” JavaScript world (JS Thread)

- Runs your React/JS code, component logic, state management, business rules, etc.
- Powered by the **JavaScriptCore** engine (or **Hermes**).

### âœ” Native world (Native Modules + UI Thread)

- Handles native rendering, animations, device APIs, sensors, network, filesystem, etc.

ðŸ“Œ The Bridge passes messages back and forth between JS and Native using **serialized JSON-like messages**.

But this communication is **asynchronous**, meaning JS cannot directly call native functions synchronously.

---

## ðŸ§µ 2. React Native Threads Overview

React Native uses multiple threads internally, the 3 most important:

### ðŸ”¹ 1. JS Thread

- Executes all your JavaScript code.
- Runs React's reconciliation (diffing virtual DOM).
- Runs event handlers (e.g., `onPress`, `onChangeText`).
- If this thread is blocked â†’ App UI feels laggy.

ðŸ‘‰ Heavy operations on JS Thread cause **frame drops**.

### ðŸ”¹ 2. Native/UI Thread (Main Thread)

- Handles the rendering of native UI components.
- Processes animations, gestures, drawing, layout.
- Must stay smooth for **60 FPS** performance.

ðŸ‘‰ If this thread is busy â†’ UI glitches or freezes.

### ðŸ”¹ 3. Shadow Thread

- Used by React Native layout engine (**Yoga**).
- Calculates layout before rendering UI components.

---

## ðŸ”Œ 3. How the Bridge Works (Simple Explanation)

### When JS wants to update the UI:

1. JS thread prepares a message (e.g., "Update `<View>` color to blue")
2. Message is **serialized** & sent over the Bridge
3. Native side receives it
4. UI thread applies changes in the actual native view

### When a native module sends data back:

1. Native prepares a message (e.g., GPS update)
2. Sends it to JS via the Bridge
3. JS thread receives the event callback

ðŸ’¡ This is **slow** compared to purely native because:

**Serialization + batching + async communication**
â†’ can create delays.

---

## â± Why is the Bridge a Performance Bottleneck?

Because the Bridge:

- Requires **JSON serialization**
- Uses **asynchronous batched messages**
- Has **no shared memory**
- Cannot send large data efficiently (e.g., images, videos)

### Example issues:

- Slow list scrolling with many interactions
- Delayed UI updates if JS thread is busy
- Slow communication for heavy native modules

---

## ðŸš€ 4. What Improved After the "New Architecture" (Fabric & JSI)?

Interviewers often ask about the **new architecture**.

React Native 0.71+ has:

### âœ” JSI (JavaScript Interface)

Allows **direct synchronous communication** between JS and Native (no Bridge).

### âœ” TurboModules

Faster Native Modules with **lazy loading**.

### âœ” Fabric Renderer

Modern UI renderer with **synchronous layout updates**.

ðŸ‘‰ In the new architecture, the Bridge is mostly **replaced**, improving speed and reducing overhead.

---

## ðŸ“ 5. Interview-style Summary Answer

Here is a perfect answer you can give during an interview:

> **React Native uses a Bridge to communicate between JavaScript and Native code. The JavaScript runs on the JS thread, while native UI updates happen on the main/UI thread. The Bridge sends asynchronous, serialized messages between these threads. Because communication is async and involves serialization, it can become a performance bottleneck for heavy operations.**
>
> **In the new React Native architecture, this Bridge is replaced by JSI, TurboModules, and the Fabric renderer, which allow direct, synchronous access to native functions and much faster UI updates.**
