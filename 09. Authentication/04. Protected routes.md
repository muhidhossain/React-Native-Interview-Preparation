# Protected Routes in React Native â€” Interview-Ready Explanation

---

## What are Protected Routes?

**Protected routes** (also called **private routes, secured screens, or auth-guarded screens**) are screens that the user can only access after authentication.

**Example:** Dashboard, Profile, Orders, Settings.

If the user is not logged in, the app must prevent access and redirect them to Login / Signup screens.

---

## âœ… Why Protected Routes Are Needed

- To secure user data
- To avoid showing sensitive UI without login
- To avoid API calls with invalid tokens
- To improve navigation flow (Login â†’ App, Logout â†’ Auth)

---

## ğŸ¯ How Protected Routes Are Implemented in React Native

In React Native, protected route logic is usually implemented using **React Navigation + Auth Context/State**.

The common approach:

1. **Maintain authentication state**

   - Using **Context API**
   - Or using **Redux / Zustand / Jotai**
   - Or using **async storage** to store token

2. **Switch navigator based on auth state**
   - If authenticated â†’ show **App Stack**
   - If not authenticated â†’ show **Auth Stack**

---

## ğŸ“Œ Architecture (Most Common Setup)

```javascript
<NavigationContainer>
  {isLoggedIn ? <AppStack /> : <AuthStack />}
</NavigationContainer>
```

This is the simplest and most effective pattern.

---

## ğŸ§© Example: AuthContext + Protected Navigation

### AuthContext.js

```javascript
import { createContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [userToken, setUserToken] = useState(null);

  useEffect(() => {
    const loadToken = async () => {
      const token = await AsyncStorage.getItem('token');
      setUserToken(token);
    };
    loadToken();
  }, []);

  return (
    <AuthContext.Provider value={{ userToken, setUserToken }}>
      {children}
    </AuthContext.Provider>
  );
};
```

---

### App.js

```javascript
import { NavigationContainer } from '@react-navigation/native';
import { AuthProvider, AuthContext } from './AuthContext';
import AppStack from './src/navigation/AppStack';
import AuthStack from './src/navigation/AuthStack';
import { useContext } from 'react';

export default function App() {
  return (
    <AuthProvider>
      <MainNavigator />
    </AuthProvider>
  );
}

const MainNavigator = () => {
  const { userToken } = useContext(AuthContext);

  return (
    <NavigationContainer>
      {userToken ? <AppStack /> : <AuthStack />}
    </NavigationContainer>
  );
};
```

---

### AuthStack.js (Screens accessible without login)

```javascript
const AuthStack = () => (
  <Stack.Navigator>
    <Stack.Screen name="Login" component={Login} />
    <Stack.Screen name="Register" component={Register} />
  </Stack.Navigator>
);
```

---

### AppStack.js (Protected screens)

```javascript
const AppStack = () => (
  <Stack.Navigator>
    <Stack.Screen name="Home" component={Home} />
    <Stack.Screen name="Profile" component={Profile} />
  </Stack.Navigator>
);
```

---

## ğŸ” How Do You Protect a Route? (Key Logic)

A route is **protected** if:

- It is only rendered **after authentication state** says the user is logged in.
- If `userToken` is missing â†’ user cannot access protected screens.

So the **"protection" is done by conditional rendering of stacks.**

---

## ğŸ”„ Logout Handling

To protect routes after logout:

```javascript
setUserToken(null);
AsyncStorage.removeItem('token');
```

This will automatically switch **AppStack â†’ AuthStack**.

---

## ğŸ“ Common Interview Questions & Answers

### Q: How do you secure routes in React Native?

â†’ By using **authentication state** to conditionally render navigation stacks.

---

### Q: Can protected routes be bypassed by going back?

â†’ **No**, because the stack itself is replaced. Navigation state resets.

---

### Q: What if token expires while user is inside app?

**Best practices:**

1. Detect **401 API response**
2. Clear token
3. Redirect to Login screen

---

### Q: Where should you store tokens?

- **AsyncStorage** (not fully secure, but common in RN apps)
- **SecureStore** (Expo)
- **react-native-keychain** (better security)

---

## ğŸ¯ Final Summary

**Protected routes = controlling which screens the user can access based on authentication.**

In React Native, this is done by:

- âœ” Maintaining auth state
- âœ” Conditional rendering of navigators
- âœ” Redirecting based on login/logout state

**This is a very common interview topic, especially for React Native dev roles.**
