# Async Operations in Redux â€” Thunk vs Saga

---

## ðŸ§  Why async handling matters in Redux

Redux itself is **synchronous by design** â€” reducers must be pure and can't handle asynchronous tasks like API calls, timers, file I/O, storage requests, Bluetooth, camera permissions, push notifications, etc.

So to handle async workflows in React Native apps, we use middleware like:

| Middleware      | Best for                                     | Style                    |
| --------------- | -------------------------------------------- | ------------------------ |
| **Redux Thunk** | Simple async calls (API, DB, Storage)        | Easy, function-based     |
| **Redux Saga**  | Complex async logic, cancellation, sequences | Generator-function-based |

---

## ðŸ”¹ 1. Redux Thunk

### ðŸ” Concept

**Redux Thunk** allows you to return a **function** from an action, instead of an action object.
Inside that function you can perform async work (fetch API, wait, logic based on state) then dispatch success/failure actions.

### How it works

1. A thunk action is dispatched
2. It runs asynchronously
3. It dispatches actions when job completes

### Example (Fetch user from API)

```javascript
// actions/userActions.js
export const fetchUser = () => {
  return async (dispatch) => {
    dispatch({ type: 'USER_REQUEST' });

    try {
      const res = await fetch('https://api.example.com/user');
      const data = await res.json();

      dispatch({ type: 'USER_SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'USER_FAILURE', error });
    }
  };
};
```

### When to choose Thunk

âœ” Small-medium apps  
âœ” Simple API calls  
âœ” Quick to write & easy to debug  
âœ” Perfect for React Native CRUD apps

**Limitation:** Hard to manage chained async flows, complex logic, parallel requests, cancellation, retry, debounce.

---

## ðŸ”¹ 2. Redux Saga

### ðŸ” Concept

**Redux Saga** uses **generator functions** (`function*`) to manage async operations.
You write **Sagas** that listen to dispatched actions and handle side effects in a more controllable & testable way.

It behaves like a **background worker** in your Redux app.

### Example (API call using Saga)

```javascript
// sagas/userSaga.js
import { call, put, takeLatest } from 'redux-saga/effects';

const fetchUserApi = () =>
  fetch('https://api.example.com/user').then((res) => res.json());

function* fetchUserSaga() {
  try {
    const data = yield call(fetchUserApi);
    yield put({ type: 'USER_SUCCESS', payload: data });
  } catch (e) {
    yield put({ type: 'USER_FAILURE', error: e });
  }
}

export function* watchUserSaga() {
  yield takeLatest('USER_REQUEST', fetchUserSaga);
}
```

### Key Saga Features (Important for interview)

| Feature                     | Explanation                                      |
| --------------------------- | ------------------------------------------------ |
| `takeLatest`                | Runs only latest call (useful for search typing) |
| `takeEvery`                 | Runs every dispatched action                     |
| `call()`                    | Handles promises like async/await                |
| `put()`                     | Dispatches actions                               |
| `cancel()`, `race()`        | Task cancellation (very useful in RN)            |
| Parallel & sequential flows | Easily controllable logic                        |
| Better for large-scale apps | Handles business logic outside UI                |

### When to choose Saga

âœ” Complex async workflows  
âœ” Multiple chained APIs  
âœ” Background tasks + cancellation  
âœ” Offline sync, push notifications, WebSocket events

---

## Quick Interview Comparison Answer â¬‡

> **Redux Thunk** is lightweight and easy for simple async actions.
> It works by returning a function inside an action where async tasks run.
>
> **Redux Saga** is more powerful and better suited for complex applications.
> It uses generator functions to control async flows with features like cancellation, retries, concurrency and watchers.
>
> If the app has simple API calls â†’ use **Thunk**.  
> If the app has complex background logic â†’ use **Saga**.
