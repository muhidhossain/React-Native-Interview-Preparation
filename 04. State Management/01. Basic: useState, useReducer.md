# useState & useReducer â€” Basic State Management

---

## ðŸ”¹ useState â€” Basic State Management Hook

### ðŸ‘‰ What it does

`useState` lets a component store and update simple, local state.
It re-renders the component whenever the state changes.

### ðŸ”¥ Syntax

```javascript
const [state, setState] = useState(initialValue);
```

### Example in React Native:

```javascript
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="Increase" onPress={() => setCount(count + 1)} />
    </View>
  );
}
```

### Interview talking points

- Perfect for simple & small state updates
- State updates are independent
- Easy to write & read
- Can store numbers, strings, booleans, arrays, objects

---

## ðŸ”¹ useReducer â€” Advanced & Structured State Management

### ðŸ‘‰ What it does

`useReducer` manages complex state through actions and a reducer function.
Useful when state updates depend on previous state or have multiple condition-based transitions.

### ðŸ”¥ Syntax

```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

### Example in React Native:

```javascript
import React, { useReducer } from 'react';
import { View, Text, Button } from 'react-native';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <View>
      <Text>Count: {state.count}</Text>
      <Button title="+" onPress={() => dispatch({ type: 'INCREMENT' })} />
      <Button title="-" onPress={() => dispatch({ type: 'DECREMENT' })} />
      <Button title="Reset" onPress={() => dispatch({ type: 'RESET' })} />
    </View>
  );
}
```

### Interview talking points

- Good for complex state logic
- Useful when multiple actions modify the same state
- Makes updates predictable using reducer pattern
- Similar to Redux-style state management but local to component

---

## ðŸ†š useState vs useReducer â€” When to use what?

| Feature        | useState                       | useReducer                          |
| -------------- | ------------------------------ | ----------------------------------- |
| Complexity     | Simple                         | Mediumâ€“High                         |
| Best for       | UI state, form fields, toggles | Complex logic, multi-action updates |
| Update style   | direct `setState()`            | `dispatch(action)`                  |
| Code structure | compact, easier                | scalable, predictable               |
| Similar to     | Basic state                    | Redux-like mini store               |

---

## Quick Interview Answer Summary:

> **useState** is for simple state such as counters, toggles, inputs.  
> **useReducer** is used when the state grows complex, involves multiple actions, or requires predictable structured updates like Redux.
