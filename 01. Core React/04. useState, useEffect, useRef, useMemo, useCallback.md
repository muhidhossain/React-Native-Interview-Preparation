# useState, useEffect, useRef, useMemo, useCallback

## âœ… 1. useState

### What it is

A React Hook that lets functional components manage local state.

### Why it's used

- To store values that change over time.
- To re-render the component when the state changes.

### Syntax

```jsx
const [count, setCount] = useState(0);
```

### Key Points

- Updating state **triggers a re-render**.
- Initial value is used **only on the first render**.
- State updates are **asynchronous**.
- Good for UI states: inputs, toggles, counters, fetched data.

### Interview Tip

Explain that functional components became powerful after Hooks because `useState` replaced class state (`this.state`).

---

## âœ… 2. useEffect

### What it is

A Hook for running **side effects** in functional components.

Side effects include:

- API calls
- Subscriptions / event listeners
- Timers
- Updating document title / app state
- Cleanup logic

### Syntax

```jsx
useEffect(() => {
  // effect
  return () => {
    // cleanup (optional)
  };
}, [dependency]);
```

### How dependencies work

| Dependency    | When it Runs                                      |
| ------------- | ------------------------------------------------- |
| `[]`          | Runs once on mount (`componentDidMount`).         |
| `[values]`    | Runs when `values` change (`componentDidUpdate`). |
| No dependency | Runs on every re-render.                          |

### Cleanup

Used for removing event listeners, clearing timers, unsubscribing, etc.

### Interview Tip

Say: `useEffect` combines lifecycle methods (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) into one API.

---

## âœ… 3. useRef

### What it is

A Hook that gives you a **mutable object** that:

- persists across renders,
- does **not trigger re-renders** when changed.

### Common Uses

**Accessing DOM elements** (web only)

```jsx
const inputRef = useRef(null);
```

**Storing mutable values** (React + React Native)

- previous state
- timeout id
- counters

**Avoiding re-renders**

```jsx
const renderCount = useRef(0);
renderCount.current++;
```

### Interview Tip

Mention that `useRef` in React Native is commonly used for:

- `ScrollView` refs
- `FlatList` refs
- Animation refs (Reanimated, Lottie)

---

## âœ… 4. useMemo

### What it is

A Hook to **memoize expensive computations** so they don't re-run unnecessarily.

### Syntax

```jsx
const value = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### When to use

- Heavy calculations
- Filtering large lists
- Formatting large data
- Derived state from props

### When NOT to use

- Don't use for simple math (causes overhead)
- Don't use everywhere â€” interviewers hate over-optimization

### Interview Tip

Say:

> "useMemo improves performance by caching computed results. It does NOT prevent re-renders; use it for expensive calculations."

---

## âœ… 5. useCallback

### What it is

A Hook that **memoizes function definitions** so the function is stable between renders.

### Syntax

```jsx
const handlePress = useCallback(() => {
  console.log('clicked');
}, [dependency]);
```

### Why it matters

Every re-render creates new function references in JS.
This can cause unnecessary re-renders in child components that use `React.memo`.

`useCallback` helps when:

- Passing callbacks to memoized children
- Avoiding re-creation of handlers on every render
- Stable references for dependencies (like inside `useEffect`)

### Interview Tip

Explain the difference:

- `useMemo` memoizes a **value**
- `useCallback` memoizes a **function**

Both help performance but serve different purposes.

---

## ðŸŽ¯ Summary Table (Interview Cheat Sheet)

| Hook          | Purpose                          | Triggers Re-render?                   | Common Uses                            |
| ------------- | -------------------------------- | ------------------------------------- | -------------------------------------- |
| `useState`    | Local state                      | Yes                                   | Input values, toggles, UI state        |
| `useEffect`   | Side effects                     | No (but can cause with state updates) | API calls, subscriptions, timers       |
| `useRef`      | Persist values without re-render | No                                    | DOM refs, saving values across renders |
| `useMemo`     | Memoize values                   | No                                    | Heavy computations                     |
| `useCallback` | Memoize functions                | No                                    | Stable callback references             |
