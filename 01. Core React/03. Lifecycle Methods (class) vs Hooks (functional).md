# Lifecycle Methods (Class Components) vs Hooks (Functional Components)

React originally used class components with lifecycle methods.
From **React 16.8 onward**, **Hooks** enabled the same (and more) features using functional components.

Both React and React Native follow the same lifecycle principles, because React Native uses React under the hood.

---

## üß© Lifecycle Methods in Class Components

Class components have specific lifecycle phases:

### 1Ô∏è‚É£ Mounting Phase (Component Created & Inserted in UI)

**Methods:**

- **`constructor()`**

  - Initialize state
  - Bind methods

- **`static getDerivedStateFromProps()`**

  - Sync props to state
  - Rarely used

- **`render()`**

  - Return UI

- **`componentDidMount()`**
  - Runs once after first render
  - Best place for API calls, subscriptions, timers

### 2Ô∏è‚É£ Updating Phase (Props/State changes ‚Üí re-render)

**Methods:**

- **`static getDerivedStateFromProps()`**

- **`shouldComponentUpdate()`**

  - Controls re-render (performance optimization)

- **`render()`**

- **`getSnapshotBeforeUpdate()`**

  - Capture pre-update DOM values (rare)

- **`componentDidUpdate()`**
  - API calls based on updated values

### 3Ô∏è‚É£ Unmounting Phase (Component removed)

**Method:**

- **`componentWillUnmount()`**
  - Cleanup: remove listeners, cancel API, clear timers

### üí° Summary Table (Class Lifecycle)

| Phase   | Methods                                                 | Purpose                   |
| ------- | ------------------------------------------------------- | ------------------------- |
| Mount   | `constructor`, `render`, `componentDidMount`            | Setup, initial data fetch |
| Update  | `shouldComponentUpdate`, `render`, `componentDidUpdate` | Handle updates            |
| Unmount | `componentWillUnmount`                                  | Cleanup                   |

---

## ‚öõÔ∏è Hooks in Functional Components

Hooks provide lifecycle-like behavior using functions.

### üî• Major Hooks that Replace Lifecycle Methods

#### üìå `useState()`

Replaces `this.state` and `this.setState`

#### üìå `useEffect()` ‚Äî The Lifecycle Replacement

`useEffect()` can mimic all three lifecycle phases.

##### 1Ô∏è‚É£ `componentDidMount` ‚Üí `useEffect(() => {...}, [])`

Runs once when component mounts.

```jsx
useEffect(() => {
  fetchData();
}, []);
```

##### 2Ô∏è‚É£ `componentDidUpdate` ‚Üí `useEffect(() => {...}, [dependencies])`

Runs when dependencies change.

```jsx
useEffect(() => {
  console.log('State updated:', count);
}, [count]);
```

##### 3Ô∏è‚É£ `componentWillUnmount` ‚Üí return cleanup function

Runs when component unmounts.

```jsx
useEffect(() => {
  const subscription = watchSomething();
  return () => subscription.remove(); // cleanup
}, []);
```

### ‚ö° Other Hooks Replacing Class Behaviors

#### üìå `useRef()`

- Replaces `createRef`
- Stores mutable values without re-rendering

#### üìå `useMemo()` & `useCallback()`

- Replace `shouldComponentUpdate` optimization logic

#### üìå `useContext()`

- Replaces context usage in class components

#### üìå Custom Hooks

- No class equivalent
- Reusable logic extracted into functions ‚Üí huge advantage

---

## üÜö Side-by-Side Comparison

| Concept                 | Class Component         | Functional Component (Hooks)             |
| ----------------------- | ----------------------- | ---------------------------------------- |
| State                   | `this.state`            | `useState`                               |
| Update state            | `this.setState`         | `setState` function                      |
| Initial Mount           | `componentDidMount`     | `useEffect(() => {}, [])`                |
| When props/state change | `componentDidUpdate`    | `useEffect(() => {}, [deps])`            |
| Cleanup                 | `componentWillUnmount`  | return cleanup function                  |
| Optimization            | `shouldComponentUpdate` | `React.memo` / `useMemo` / `useCallback` |
| Refs                    | `createRef`             | `useRef`                                 |
| Reusable logic          | No easy way             | Custom Hooks üëç                          |

---

## üì± React vs React Native?

- Lifecycle behavior is **identical**.
- Only the UI components differ (e.g., `<View>` vs `<div>`).
- The logic of `useEffect`, `useState`, `componentDidMount`, etc. stays the same.

So your lifecycle explanation works for both **React and React Native interviews**.

---

## üß† Interview Tip

If interviewer asks:
**"Why did React move from lifecycle methods to Hooks?"**

**Answer:**

- Hooks reduce code complexity
- No need for `this`
- Easier to reuse logic via custom hooks
- Provide better performance optimization
- Easier to test
- Smaller, cleaner components

---

## ‚úÖ Short Answer for Interviews

- Class components rely on lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.
- Functional components use Hooks like `useState` and `useEffect` to manage state and lifecycle.
- `useEffect` can replace all lifecycle stages, and custom hooks allow logic reuse which classes cannot do.
- React and React Native share the same lifecycle system; only UI components differ.
