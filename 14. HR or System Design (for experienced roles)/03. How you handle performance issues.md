# How to Handle Performance Issues in React Native (Interview-Ready Explanation)

Performance is a key topic in React Native interviews. You should explain how you identify issues, what tools you use, and the strategies to fix them.

---

## ✅ 1. Identify Performance Bottlenecks

### Tools used

- **React DevTools Profiler** → finds slow components and re-renders
- **Flipper** → performance graphs, network inspection
- **Android Studio / Xcode Profilers** → CPU, memory, FPS
- **Why-Did-You-Render** → detect unnecessary re-renders

### Mention in interview:

> "First, I always profile the app to understand what's slow — unnecessary re-renders, slow JS thread, or UI thread bottlenecks."

---

## ✅ 2. Avoid Unnecessary Re-renders

This is the **most common performance issue**.

### Techniques:

- Use `React.memo` for pure components
- Use `useCallback` and `useMemo` for functions/values
- Use `keyExtractor` properly in FlatList
- Make sure props are stable (not recreated unnecessarily)

### Interview one-liner:

> "Most RN performance issues come from repeated re-renders, so I memoize components and stabilize functions using `useCallback`."

---

## ✅ 3. Optimize Lists (FlatList/SectionList)

Poorly handled lists cause lag, low FPS, and JS thread drops.

### Best Practices:

- Always use **FlatList** instead of **ScrollView** for large data
- Use `getItemLayout` for fixed height rows
- Use `initialNumToRender` wisely
- Use `windowSize` and `maxToRenderPerBatch`
- Avoid creating inline arrow functions inside `renderItem`

### Mention:

> "Optimizing FlatList is critical — I ensure virtualization is working properly and tune `windowSize`/`maxToRenderPerBatch`."

---

## ✅ 4. Heavy Calculations → Move off the JS Thread

If expensive logic runs on JS thread, UI becomes unresponsive.

### Solutions:

- Use **TurboModules** (new architecture)
- Use **JSI** for running work in native thread
- Use **react-native-reanimated** for animations
- Offload work using:
  - `react-native-threads`
  - `react-native-worker` (Web Workers)

---

## ✅ 5. Optimize Images

Bad image handling = slow loading, memory spikes.

### Fixes:

- Use proper sizes (avoid full-resolution images)
- Use **react-native-fast-image** for caching
- Use `resizeMode` to avoid layout passes
- Use **WebP** images (smaller, faster)

---

## ✅ 6. Reduce App Size

Performance improves when bundle size is smaller.

### Methods:

- Enable **Hermes** engine
- Remove unused libraries
- Use dynamic imports
- Compress assets
- `Proguard + minifyEnabled = true` (Android)

---

## ✅ 7. Use the New Architecture (Fabric + TurboModules)

### Benefits:

- Faster UI updates (Fabric)
- Faster JS ↔ Native calls (JSI)
- Less overhead than the old Bridge

### Mention:

> "Fabric reduces UI lag by synchronizing layout and rendering more efficiently."

---

## ✅ 8. Optimize Animations

Badly written animations can block the JS thread.

### Remedies:

- Use **react-native-reanimated 2+** → runs animation worklet on UI thread
- Avoid JS-based animations like `setInterval`/`setTimeout`
- Use Layout Animations
- Use Gesture Handler for smooth gestures

---

## ✅ 9. Minimize Over-the-Bridge (JS ↔ Native) Calls

Too many bridge calls = lag and bottlenecks.

### Solutions:

- Batch operations
- Avoid per-frame JS-to-native communication
- Use JSI-based libraries (no bridge)

---

## ✅ 10. Cache Data Properly

Reduces network calls + load times.

### Use:

- **AsyncStorage**
- **react-query / SWR**
- **SQLite / MMKV** for fast storage
- Memoize expensive API results

---

## ⭐ Example Interview Summary (Use This)

> "When handling performance issues, I start by profiling the app using **Flipper** and **React DevTools** to identify slow components. Most issues come from **unnecessary re-renders**, so I use `React.memo`, `useCallback`, and optimize my **FlatList virtualization**.
>
> For UI lag, I move heavy work off the JS thread using **JSI/TurboModules** or use **Reanimated** for smooth animations. I also optimize images, reduce bundle size, and ensure minimal JS-Native bridge interactions. Overall, I focus on keeping the **JS thread free** and ensuring my **UI thread stays under 16ms per frame**."
