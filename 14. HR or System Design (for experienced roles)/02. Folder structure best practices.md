# Folder Structure Best Practices (React Native)

A clean, scalable folder structure is crucial for maintainability, collaboration, and faster feature development. In React Native interviews, the goal is to show that you understand modularity, separation of concerns, and scalability.

---

## ðŸ—‚ï¸ 1. High-Level Ideal Folder Structure

```
project-root/
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ fonts/
â”‚   â”‚   â””â”€â”€ icons/
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â””â”€â”€ specific/
â”‚   â”‚
â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â””â”€â”€ Home/
â”‚   â”‚       â”œâ”€â”€ index.tsx
â”‚   â”‚       â”œâ”€â”€ styles.ts
â”‚   â”‚       â””â”€â”€ hooks/
â”‚   â”‚
â”‚   â”œâ”€â”€ navigation/
â”‚   â”‚   â”œâ”€â”€ RootNavigator.tsx
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚
â”‚   â”œâ”€â”€ contexts/
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ storage/
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚
â”‚   â”œâ”€â”€ store/  (Redux / Zustand / Jotai)
â”‚   â”‚   â”œâ”€â”€ slices/
â”‚   â”‚   â””â”€â”€ actions/
â”‚   â”‚
â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â””â”€â”€ colors.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚
â”‚   â””â”€â”€ config/
â”‚
â”œâ”€â”€ App.tsx
â””â”€â”€ package.json
```

---

## ðŸ§© 2. Why This Structure Is Considered Best Practice

### âœ” Separation of concerns

- **screens** contain UI + screen-level logic.
- **components** contain reusable building blocks.
- **services** contain external interactions (API calls, storage handling).
- **store** contains state management logic.

This ensures code does not mix concerns, making it testable and clean.

### âœ” Scalable for large teams

Each engineer can work inside isolated modules without merge conflicts.

**Example:**

- One developer works on `/screens/Chat`
- Another works on `/services/api/chatService.ts`
- No overlap â†’ fewer conflicts.

### âœ” Easier to navigate

When folders follow predictable patterns, new developers onboard faster.

**Interview point:**

> "A consistent structure reduces cognitive load and improves team productivity."

### âœ” Better for feature-based organization

Modern RN projects prefer **feature-based grouping**:

```
screens/
   Profile/
     Profile.tsx
     Profile.styles.ts
     Profile.hooks.ts
     Profile.test.ts
```

Each feature becomes a self-contained module.

---

## ðŸ§± 3. Key Folders Explained (Interview Style)

### ðŸ”¹ /components

Reusable UI elements:

- Buttons
- Loaders
- Input fields

Use `common/` for reusable shared components.

### ðŸ”¹ /screens

Each screen gets its own subfolder:

- UI file
- Styles file
- Screen-specific hooks
- Screen-level components

This is a clean, modular way of organizing features.

### ðŸ”¹ /navigation

- All navigators (stack, tab, drawer)
- Navigation types (TypeScript)

Keeps navigation logic isolated from UI.

### ðŸ”¹ /services

Handles:

**API**

```
services/
   api/
     httpClient.ts
     authService.ts
```

**Local storage**

```
services/
   storage/
     asyncStorage.ts
```

This avoids writing `fetch` or `AsyncStorage` logic inside screens.

### ðŸ”¹ /store

For global state (Redux, Zustand, Jotai, Recoil)

**Example Redux structure:**

```
store/
   slices/
   rootReducer.ts
   store.ts
```

### ðŸ”¹ /hooks

Custom hooks shared across the app:

- `useAuth()`
- `useNetwork()`
- `useLocation()`

Encourages reusability.

### ðŸ”¹ /utils

Helper functions:

- `formatDate()`
- `currencyFormatter()`
- validators

Keeps screens clean.

### ðŸ”¹ /constants

Global values:

- colors
- API endpoints
- fonts
- spacing

Promotes consistency across UI.

### ðŸ”¹ /types

TypeScript interfaces and global types:

- User type
- API response type
- Navigation type

Makes the whole project type-safe.

---

## ðŸ“¦ 4. Tips That Impress Interviewers

### 1ï¸âƒ£ Use feature-based structure in large RN apps

**Interview highlight:**

> "For apps with 20+ screens, a feature-based modular structure is more scalable than simple screen/component separation."

### 2ï¸âƒ£ Avoid dumping everything in components/

This is a common mistake:

```
components/
    Button.tsx
    ProfileCard.tsx
    ChatMessage.tsx
```

**Better:**

```
components/
    common/
    profile/
    chat/
```

### 3ï¸âƒ£ Keep files small and focused

If a file exceeds ~300 lines, it's a sign it should be split.

### 4ï¸âƒ£ Use index.ts for clean imports

```typescript
export * from './Button';
export * from './Header';
```

### 5ï¸âƒ£ Avoid circular imports

Keep `services â†’ store â†’ screens` dependency direction clean.

---

## ðŸ“ 5. Interview-Safe Explanation (Short Version)

You can memorize this:

> "A scalable React Native folder structure follows **separation of concerns**.
> I prefer organizing the project into **screens, reusable components, navigation, services (API + storage), global store, custom hooks, utilities, and constants**.
> Each screen is **feature-based**â€”its UI, styles, and hooks stay together.
> This makes the app more **maintainable, testable, and scalable** for large teams."
