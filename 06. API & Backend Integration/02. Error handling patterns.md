# Error Handling Patterns in React Native â€” Interview Preparation Guide

Error handling in React Native ensures your app stays stable, predictable, and user-friendly even when unexpected problems occur. It involves catching errors from UI components, async operations, API calls, and native modules.

---

## ğŸŸ© 1. Try/Catch for Async/Await

Most errors in React Native come from async tasks like API requests, file access, or async storage.

### âœ”ï¸ Example:

```javascript
const fetchData = async () => {
  try {
    const res = await fetch('https://api.example.com/data');
    if (!res.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await res.json();
    setState(data);
  } catch (error) {
    console.error('Fetch error:', error.message);
  }
};
```

### ğŸ’¡ When useful:

- Network/API errors
- AsyncStorage issues
- Runtime issues in async functions

---

## ğŸŸ© 2. Error Boundaries (for UI Crashes)

React components can throw rendering errors. React Native supports **Error Boundaries** (class components only!).

### âœ”ï¸ Example:

```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.log(error, info);
  }

  render() {
    return this.state.hasError ? (
      <Text>Something went wrong.</Text>
    ) : (
      this.props.children
    );
  }
}
```

### ğŸ’¡ When useful:

- Prevent entire app crashes
- Show fallback UI

---

## ğŸŸ© 3. Graceful UI Error Handling

Rather than showing blank screens, show friendly error messages.

### âœ”ï¸ Pattern:

```javascript
{
  error ? (
    <Text style={{ color: 'red' }}>{error}</Text>
  ) : (
    <DataView data={data} />
  );
}
```

### ğŸ’¡ Use cases:

- Invalid form submission
- Couldn't fetch data
- Missing permissions

---

## ğŸŸ© 4. Centralized API Error Handling

Keep all API logic in one place and normalize error responses.

### Example: Axios instance with interceptors

```javascript
import axios from 'axios';

const api = axios.create({ baseURL: 'https://api.example.com' });

api.interceptors.response.use(
  (res) => res,
  (error) => {
    const message = error.response?.data?.message || 'Something went wrong';
    return Promise.reject(new Error(message));
  }
);

export default api;
```

### âœ”ï¸ Benefits:

- No repetitive try/catch in every screen
- Unified error messages
- Better maintainability

---

## ğŸŸ© 5. Global Error Handling with ErrorUtils

React Native provides a global error handler:

```javascript
ErrorUtils.setGlobalHandler((error, isFatal) => {
  console.log('Global Error:', error);
});
```

### ğŸ’¡ Useful for:

- Logging fatal errors
- Crash reporting (Sentry, Firebase Crashlytics)

---

## ğŸŸ© 6. Handling Network Errors

Use libraries like **NetInfo** to detect offline states.

```javascript
import NetInfo from '@react-native-community/netinfo';

NetInfo.addEventListener((state) => {
  if (!state.isConnected) {
    console.log('No internet connection');
  }
});
```

### Why important?

- Prevents unnecessary API calls
- Show offline UI

---

## ğŸŸ© 7. Form Error Handling (Validation)

Use libraries like **Formik + Yup**.

### Example:

```javascript
const schema = Yup.object().shape({
  email: Yup.string().email().required(),
});
```

### Benefits:

- Prevent invalid data
- Real-time validation messages

---

## ğŸŸ© 8. Handling Native Module Errors

Native modules may crash if not handled.

```javascript
try {
  const result = await NativeExampleModule.doSomething();
} catch (error) {
  console.error('Native error:', error);
}
```

### Important for:

- Camera
- File system
- Permissions

---

## ğŸŸ© 9. Using Logging & Monitoring Tools

Production apps should track errors.

### Popular tools:

- **Sentry**
- **Firebase Crashlytics**
- **Bugsnag**

### Why needed?

- Capture crash details
- Track device info
- Get stack traces

---

## ğŸŸ¢ Interview Tips

Be ready to answer:

**âœ” How do you prevent UI crashes?**  
â€” "Using Error Boundaries."

**âœ” How do you handle API errors?**  
â€” "Use try/catch, interceptors, and fallback UI."

**âœ” What happens if a component throws during render?**  
â€” "Error Boundaries catch it and show fallback UI."

**âœ” How to detect offline mode?**  
â€” "Using NetInfo for network state."

**âœ” How to handle global crashes?**  
â€” "ErrorUtils.setGlobalHandler() or Sentry."
