# Token Handling in React Native (Access Token & Refresh Token)

Modern mobile apps (including React Native) often use **JWT-based authentication**. The core idea is to use:

- **Access Token** â†’ Short-lived, used for accessing protected APIs
- **Refresh Token** â†’ Long-lived, used to get a new access token when it expires

---

## ğŸ¯ 1. What is an Access Token?

A **short-lived token** returned by the server after login.

### Purpose

- Sent with every API request (usually in the `Authorization` header)
- Proves the user is authenticated
- Has a short expiry (e.g., 5â€“15 minutes)

### Why short-lived?

To minimize damage if leaked.

---

## ğŸ¯ 2. What is a Refresh Token?

A **long-lived token** used to refresh the access token when it expires.

### Purpose

- Client sends refresh token to `/refresh-token` endpoint
- Server returns a new access token (and sometimes a new refresh token)

### Expiry

- Long lifetime (days/weeks)
- Should NOT be sent with every request

---

## ğŸ§© 3. Typical Authentication Flow in React Native

```
[Login] â†’ Server verifies credentials
         â†’ Returns: accessToken + refreshToken

[API Requests]
  â†’ App sends accessToken in header
        "Authorization: Bearer <accessToken>"

[If expired]
  â†’ App uses refreshToken to request new accessToken
```

---

## âœ”ï¸ 4. How to Store Tokens in React Native

**DO NOT USE AsyncStorage for tokens** (not secure enough)

But many apps still do because it's simple.

### Better options:

**Secure Options**

- `expo-secure-store` (Expo apps)
- `react-native-keychain`
- `react-native-encrypted-storage` (highly recommended)

### Example using Encrypted Storage:

```javascript
import EncryptedStorage from 'react-native-encrypted-storage';

await EncryptedStorage.setItem(
  'auth',
  JSON.stringify({
    accessToken,
    refreshToken,
  })
);
```

### To retrieve:

```javascript
const session = await EncryptedStorage.getItem('auth');
const { accessToken, refreshToken } = JSON.parse(session);
```

---

## ğŸ” 5. Automatically Refreshing Access Token

You should set up:

**Axios Interceptor (recommended)**

When server returns `401 Unauthorized`, refresh the token.

```javascript
import axios from 'axios';
import EncryptedStorage from 'react-native-encrypted-storage';

const api = axios.create({
  baseURL: 'https://api.example.com',
});

// Request interceptor
api.interceptors.request.use(async (config) => {
  const session = await EncryptedStorage.getItem('auth');
  const { accessToken } = JSON.parse(session);

  config.headers.Authorization = `Bearer ${accessToken}`;
  return config;
});

// Response interceptor
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Token expired
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      const session = await EncryptedStorage.getItem('auth');
      const { refreshToken } = JSON.parse(session);

      const res = await axios.post('https://api.example.com/auth/refresh', {
        refreshToken,
      });

      const newAccessToken = res.data.accessToken;

      // store new token
      await EncryptedStorage.setItem(
        'auth',
        JSON.stringify({
          accessToken: newAccessToken,
          refreshToken,
        })
      );

      // retry original request
      api.defaults.headers.common['Authorization'] = `Bearer ${newAccessToken}`;
      return api(originalRequest);
    }

    return Promise.reject(error);
  }
);
```

---

## ğŸš¨ 6. Logout Handling

On logout:

- Delete tokens from storage
- Reset navigation stack

```javascript
await EncryptedStorage.removeItem('auth');
```

---

## ğŸ”’ 7. Security Best Practices for React Native

### âœ”ï¸ Never store tokens in Redux or React state

Tokens must be stored only in secure storage.

### âœ”ï¸ Always use HTTPS

To prevent man-in-the-middle attacks.

### âœ”ï¸ Access tokens should expire quickly

5â€“15 minutes recommended.

### âœ”ï¸ Refresh tokens should be rotated

Each refresh should return a new refresh token.

### âœ”ï¸ Logout if refresh token fails

Means refresh token is invalid â†’ login again.

---

## ğŸ‘¨â€ğŸ’» 8. Example Interview-Ready Explanation

If an interviewer asks:

ğŸ‘‰ **"How do you handle access tokens and refresh tokens in React Native?"**

You can answer:

> In React Native, I use **JWT-based authentication**.
> After login, the server returns an **access token** (short-lived) and a **refresh token** (long-lived).
> I securely store them using `react-native-encrypted-storage` or `SecureStore`.
>
> For each API request, I attach the access token in the `Authorization` header.
>
> If the token expires and the API returns `401`, I intercept it using **Axios interceptors**, send the refresh token to the refresh endpoint, get a new access token, store it again, and retry the original request automatically.
>
> If refreshing fails, I log the user out.
>
> This approach ensures secure and seamless authentication.

---

## â“ Common Interview Questions

### 1. Why do we need refresh tokens?

To avoid giving long-lived access tokens, reducing security risk.

### 2. Can access token and refresh token be the same?

No. Refresh token must be long-lived & secure. Access token must be short-lived.

### 3. Where should tokens be stored?

In secure storage, NOT AsyncStorage.

### 4. What happens if refresh token expires?

Logout â†’ ask user to login again.

### 5. Should refresh token be sent with every request?

No, only during token renewal.
