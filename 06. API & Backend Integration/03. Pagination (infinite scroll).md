# Pagination & Infinite Scroll in React Native â€” Interview Preparation Guide

In mobile apps, you often need to load a large list of data â€” e.g., posts, products, messages.
Loading everything at once is slow and inefficient.
So we use **pagination** or **infinite scrolling** to load data gradually.

---

## âœ… 1. What is Pagination?

**Pagination** means dividing data into pages and loading them chunk by chunk.

### Common Pagination Approaches:

**Offset-based pagination**

- Example: `GET /posts?offset=0&limit=20`
- Works like: Page 1 â†’ items 0â€“19, Page 2 â†’ items 20â€“39.

**Page-number pagination**

- Example: `GET /posts?page=1&limit=20`

**Cursor-based pagination (recommended)**

- Uses a cursor/ID/timestamp to fetch next results.
- Example: `GET /posts?cursor=xyz123`
- Best for real-time or frequently updated lists.

**In interviews, emphasize:**

> Cursor-based is more efficient and avoids missing/duplicating items.

---

## ðŸš€ 2. What is Infinite Scrolling?

**Infinite scroll** automatically loads more data when the user reaches the bottom of the list.

In React Native, infinite scroll is usually done with **FlatList**.

---

## ðŸ’¡ 3. How Infinite Scroll Works in React Native

### Key FlatList props for infinite scroll:

| Prop                    | Purpose                                     |
| ----------------------- | ------------------------------------------- |
| `onEndReached`          | Triggered when user scrolls near the bottom |
| `onEndReachedThreshold` | How early (0â€“1) to pre-load the next page   |
| `ListFooterComponent`   | Loading spinner at the bottom               |
| `refreshing`            | For pull-to-refresh                         |
| `onRefresh`             | Fetch new data on pull refresh              |

---

## ðŸ“Œ 4. Infinite Scroll Example (React Native + FlatList)

```javascript
import React, { useEffect, useState } from 'react';
import { View, ActivityIndicator, FlatList, Text } from 'react-native';

export default function InfiniteScrollExample() {
  const [data, setData] = useState<any[]>([]);
  const [page, setPage] = useState(1);
  const [loadingMore, setLoadingMore] = useState(false);
  const [refreshing, setRefreshing] = useState(false);

  const fetchData = async (pageNumber = 1) => {
    const response = await fetch(
      `https://example.com/api/items?page=${pageNumber}&limit=20`
    );
    const result = await response.json();

    if (pageNumber === 1) {
      setData(result.items);
    } else {
      setData(prev => [...prev, ...result.items]);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleLoadMore = () => {
    if (!loadingMore) {
      setLoadingMore(true);
      const nextPage = page + 1;
      fetchData(nextPage).finally(() => {
        setPage(nextPage);
        setLoadingMore(false);
      });
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    setPage(1);
    fetchData(1).finally(() => setRefreshing(false));
  };

  return (
    <FlatList
      data={data}
      renderItem={({ item }) => <Text style={{ padding: 20 }}>{item.title}</Text>}
      keyExtractor={(item, index) => index.toString()}
      onEndReached={handleLoadMore}
      onEndReachedThreshold={0.5}
      ListFooterComponent={
        loadingMore ? <ActivityIndicator size="large" /> : null
      }
      refreshing={refreshing}
      onRefresh={handleRefresh}
    />
  );
}
```

---

## ðŸ§  5. Common Interview Questions & Answers

### Q1. How do you prevent multiple API calls on fast scroll?

- Use a `loadingMore` state flag
- Debounce `onEndReached`
- Ensure API isn't triggered while previous request is pending

### Q2. Why does onEndReached trigger multiple times?

Because the list re-renders or the threshold is too high.

**Fix:**

- Set `onEndReachedThreshold={0.1}`
- Use a lock (`loadingMore`)

### Q3. Infinite scroll vs pagination UI â€” which is better?

- **Infinite scroll** â†’ good for feeds (Facebook, Instagram)
- **Pagination** â†’ better for search results/products

### Q4. How to combine pull-to-refresh + infinite scroll?

- `onRefresh` refreshes from page 1
- `onEndReached` loads next page

---

## ðŸ›  6. Best Practices for Infinite Scroll

âœ” Use `keyExtractor` to avoid rerenders  
âœ” Keep API lightweight (20â€“30 items max per request)  
âœ” Show a footer loader  
âœ” Avoid duplicate items (Set or unique IDs)  
âœ” Prefer cursor-based pagination for large datasets  
âœ” Cache data for smoother scrolling

---

## ðŸ“ Final Interview Summary

> **Pagination** is splitting data into chunks.  
> **Infinite scroll** is auto-loading next chunks when reaching the bottom.

In React Native, infinite scroll is mainly implemented with:

- `FlatList`
- `onEndReached`
- `ListFooterComponent`
- `onRefresh`

**Knowing how to handle loading states, debouncing, duplicates, and cursor-based APIs will impress interviewers.**
